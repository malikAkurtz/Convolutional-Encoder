#include <iostream>
#include <stdio.h>
#include <vector>
#include <string>
#include <bitset>
#include <cstdlib>
#include <time.h>
#include <cmath>
#include <map>
#include <bitset>
#include <fstream>
#include "utility.h"
#include "convViterbi.h"

// Alphabet: Binary i.e (A = {0,1}), length of alphabet q = 2

// Length: The length of the codeword will be equal to the number of generator polynomials corresponding to that particular k value (currently this is 5)

// Dimension: For convolutional encoders, the dimension generally refers to the number of input bits per unit time that the encoder processes 
// rather than the number of independent vectors in a linear subspace (as in block codes). R = k / n, k = # input bits, n = # output bits

// Distance: In convolutional codes, a related metric called the free distance ùëëfree is often used instead of the traditional minimum distance. 
// it is the minimum Hamming weight of the difference between any two output sequences generated by distinct input sequences
// A convolutional code has the potential to correct floor(dfree - 1 / 2) errors per code sequence


// // Encode Method
std::vector<bool> encode(std::vector<bool> code, int k, std::vector<unsigned int> genPolynomials, int &timeSteps) { // k is the constraint length i.e length of the shift register we want to use
    std::vector<bool> encodedVector = {};
    std::vector<bool> sliding_window = {};
    std::vector<bool> outputVector = {};
    // Follow this same procedure till every bit is processed
    for (int i = 0; i < code.size(); i++) {
        sliding_window.clear();
        for (int m = 0; m < k-i-1; m++) {
            sliding_window.push_back(0);
        }
        for (int j = 0; j < k - (std::max((k-i-1), 0));j++) {
            if (i >= k) {
                sliding_window.push_back(code[j-(k-i-1)]);
            }
            else {
                sliding_window.push_back(code[j]);
            }
            
        }
        std::vector<bool> outputVector = generateOutput(sliding_window, genPolynomials);
        encodedVector.insert(encodedVector.end(), outputVector.begin(), outputVector.end());

        timeSteps += 1;
    }
    return encodedVector;
}


std::vector<bool> viterbiDecode(std::vector<bool> noisy_encoded_code, int k, std::vector<std::vector<bool>> states, 
    std::vector<unsigned int> genPolynomials, int &timeSteps, std::vector<std::vector<vNode>> &trellis) {

    std::vector<bool> decoded = {};
    
    int outputBits = genPolynomials.size();
    trellis.resize(timeSteps + 1);
    
    //initialize the only node at t = 0 (0,0)

    for (int t = 0; t < timeSteps+1; t++) {
        for (int s = 0; s < states.size(); s++) {
            vNode defaultNode;

            defaultNode.state = s;
            defaultNode.inputArrivalBit = 0;
            defaultNode.cumHammingDistance = INT_MAX;
            trellis[t].push_back(defaultNode);          
            
        }
    }

    trellis[0][0].cumHammingDistance = 0; // assuming out register will start at an intial state of State 0

    //printTrellisStates(trellis);



    for (int t = 1; t <= timeSteps; t++) {
        std::vector<bool> observedInput = std::vector<bool>(noisy_encoded_code.begin() + (outputBits*(t-1)), noisy_encoded_code.begin() + (outputBits*(t-1) + outputBits));
        for (int s = 0; s < states.size(); s++) {
            // cout << "------------------------------------------------------------------------" << endl;
            // cout << "State is: " << s << endl;
            bool transitionBit = s % 2;
            trellis[t][s].inputArrivalBit = transitionBit;
            
            int currentState = vecBoolToInt(states[s]);

    
            int firstPrevState = (currentState >> 1);
            if (trellis[t-1][firstPrevState].cumHammingDistance != INT_MAX) {
                // cout << "Previous state for first input is: " << to_string(firstPrevState) << endl;
                std::vector<bool> firstPotentialInput = calculatePotentialInput(states[firstPrevState], transitionBit);
                std::vector<bool> firstExpected = generateOutput(firstPotentialInput, genPolynomials);
                // cout << "Our expected is:    " << firstExpected << endl;
                // cout << "Our observation is: " << observedInput << endl;
                int firstHammingDistance = trellis[t-1][firstPrevState].cumHammingDistance + calculateHammingDistance(observedInput, firstExpected);
                // cout << "So the cumulative hamming distance would be: " << firstHammingDistance << endl;
                if (firstHammingDistance < trellis[t][s].cumHammingDistance) {
                    trellis[t][s].cumHammingDistance = firstHammingDistance;
                    trellis[t][s].inputArrivalBit = transitionBit;
                }
            }
            

            int secondPrevState = ((currentState) >> 1) | (1 << (k-2));
            if (trellis[t-1][secondPrevState].cumHammingDistance != INT_MAX) {
                // cout << "Previous state for second input is: " << to_string(secondPrevState) << endl;
                std::vector<bool> secondPotentialInput = calculatePotentialInput(states[secondPrevState], transitionBit);
                std::vector<bool> secondExpected = generateOutput(secondPotentialInput, genPolynomials);
                // cout << "Our expected is:    " << secondExpected << endl;
                // cout << "Our observation is: " << observedInput << endl;
                int secondHammingDistance = trellis[t-1][secondPrevState].cumHammingDistance + calculateHammingDistance(observedInput, secondExpected);
                // cout << "So the cumulative hamming distance would be: " << secondHammingDistance << endl;
                if (secondHammingDistance < trellis[t][s].cumHammingDistance) {
                    trellis[t][s].cumHammingDistance = secondHammingDistance;
                    trellis[t][s].inputArrivalBit = transitionBit;
                }
            }
        // cout << "------------------------------------------------------------------------" << endl;
        }
    }

    // printTrellisStates(trellis);

    return getOriginalCode(trellis);
}
